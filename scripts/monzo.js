export class Monzo{static#t=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97];static one=new Monzo(new Map);factors;constructor(t){this.factors=t}get value(){let t=1;for(const[o,r]of this.factors)t*=Math.pow(o,r);return t}get pitchDistance(){let t=0;for(const[o,r]of this.factors)t+=Math.abs(r);return t}get isOnly2(){return 1===this.factors.size&&this.factors.has(2)}get pitch(){return Math.log2(this.value)}get pitchClass(){const t=this.pitch;return t-Math.floor(t)}get minPrime(){let t=1/0;for(const[o,r]of this.factors)0!==r&&o<t&&(t=o);return t===1/0?1:t}get maxPrime(){let t=1;for(const[o,r]of this.factors)0!==r&&o>t&&(t=o);return t}toPitchClassMonzo(){const t=Math.floor(Math.log2(this.value));return Monzo.divide(this,Monzo.from2Factor(t))}quantizedValue(t){return t<1?this.value:Math.pow(2,this.quantizedPitch(t))}quantizedPitch(t){if(t<1)return this.pitch;let o=0;for(const[r,n]of this.factors)o+=Math.round(Math.log2(r)*t)*n;return o/t}quantizedPitchClass(t){if(t<1)return this.pitchClass;let o=0;for(const[r,n]of this.factors)o+=Math.round(Math.log2(r)*t)*n;return(o%t+t)%t/t}reciprocal(){const t=new Map;for(const[o,r]of this.factors)t.set(o,-r);return new Monzo(t)}toString(){let t="";for(const[o,r]of this.factors)r>0?t+=`${o}^${r} `:r<0&&(t+=`${o}^(${-r}) `);return t.trim()}static fromInt(t){const o=new Map;let r=t;for(const t of Monzo.#t)for(;t<=r&&r%t===0;)if(o.set(t,(o.get(t)??0)+1),r/=t,r<=1)return new Monzo(o);for(let t=101;t<=r;t++)for(;t<=r&&r%t===0;)if(o.set(t,(o.get(t)??0)+1),r/=t,r<=1)return new Monzo(o);return new Monzo(o)}static fromFraction(t,o){return Monzo.divide(Monzo.fromInt(t),Monzo.fromInt(o))}static multiply(t,o){const r=new Map;for(const[o,n]of t.factors)r.set(o,n);for(const[t,n]of o.factors){const o=(r.get(t)??0)+n;0===o?r.delete(t):r.set(t,o)}return new Monzo(r)}static divide(t,o){return Monzo.multiply(t,o.reciprocal())}static getOctaveFactor(t){let o=0;for(const[r,n]of t.factors)2!==r&&(o+=Math.floor(Math.log2(r))*n);return o}static from2Factor(t){return new Monzo(new Map([[2,t]]))}static getShasavicOctaveFactor(t){let o=0;for(const[r,n]of t.factors)3===Math.round(r)?o+=n:2!==r&&(o+=2*n);return o}static parseMonzos(t){return t.trim().split(/\s+/).map(t=>{if(t.includes("/")){const[o,r]=t.split("/").map(Number);return Monzo.fromFraction(o??1,r??1)}return Monzo.fromInt(Number(t))})}}