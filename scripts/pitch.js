import{Monzo}from"./monzo.js";const primes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97];export class XLengthType{static Integer=new XLengthType(126.185950714291,null);static OctaveReduced=new XLengthType(341.902258270291,Monzo.getOctaveFactor);static Shasavic=new XLengthType(341.902258270291,Monzo.getShasavicOctaveFactor);scale;getOctaveFactor;constructor(t,o){this.scale=t||128,this.getOctaveFactor=o||(()=>0)}toStructual(t){let o=this.getOctaveFactor(t);return 0===o?t:Monzo.multiply(t,Monzo.from2Factor(o))}fromStructual(t){let o=this.getOctaveFactor(t);return 0===o?t:Monzo.divide(t,Monzo.from2Factor(o))}}export function parsePitches(t,o,e){const n=t.trim().split(/\s+/),r=[];for(let t of n){let n=!1;t.startsWith("x")&&(n=!0,t=t.substring(1));let i=null;if(t.startsWith("[")&&t.includes(",")&&t.endsWith(">")){const o=t.substring(1,t.length-1).split(",").map(Number),e=new Map;for(let t=0;t<o.length;t++){const n=primes[t],r=o[t];void 0!==r&&0!==r&&void 0!==n&&e.set(n,r)}i=new Monzo(e)}else if(t.includes("/")){const[o,e]=t.split("/").map(Number);i=Monzo.fromFraction(o??1,e??1)}else i=Monzo.fromInt(Number(t));let s=i;i=e.toStructual(i),o&&(i.factors.delete(2),s=e.fromStructual(i));const c=r.find(t=>0===Monzo.divide(i,t.monzo).pitchDistance);c?c.mute=n&&c.mute:r.push({mute:n,monzo:i,originalMonzo:s})}return r}function addNearPitch(t){for(const o of t)if(!o.added)for(let e=0;e<=o.distances.length;e++)if(1===o.distances[e]&&t[e]?.added)return o.added=!0,!0;return!1}function addNearPitches(t){for(;addNearPitch(t););}function isAllAdded(t){return t.every(t=>t.added)}function getNearestAddablePitch(t){let o=Number.MAX_VALUE,e=null;for(const n of t){if(n.added)continue;let r=n.norm,i=Monzo.one;for(let o=0;o<=n.distances.length;o++){const e=t[o],s=n.distances[o];e&&s&&e.added&&s<r&&(r=s,i=e.pitch.monzo)}r<o&&(o=r,e={pitch:n.pitch.monzo,other:i})}return e}function getInterpolatedPitch(t){const o=getNearestAddablePitch(t);if(!o)return[];const{pitch:e,other:n}=o,r=Monzo.divide(e,n),i=[];let s=n.factors;for(const[t,o]of[...r.factors].sort(([t],[o])=>2===t?1:2===o?-1:t-o)){const e=Math.abs(o),n=Math.sign(o);for(let o=0;o<e;o++){s=new Map(s),s.set(t,(s.get(t)??0)+n);const o=new Monzo(s);i.push({mute:!0,monzo:o,originalMonzo:o})}}return i.pop(),i}function addInterpolatings(t,o){for(const e of t)e.added||e.distances.push(...o.map(t=>Monzo.divide(e.pitch.monzo,t.monzo).pitchDistance));t.push(...o.map(t=>({pitch:t,distances:[],norm:0,added:!0})))}export function interpolateMutedNote(t){const o=t.map(o=>{const e=o.monzo.pitchDistance;return{pitch:o,distances:t.map(t=>Monzo.divide(o.monzo,t.monzo).pitchDistance),norm:e,added:e<=1}});if(o.every(t=>0!==t.norm)){const e={mute:!0,monzo:Monzo.one,originalMonzo:Monzo.one};t.push(e),addInterpolatings(o,[e])}for(let e=0;e<100;e++){if(addNearPitches(o),isAllAdded(o))return;const e=getInterpolatedPitch(o);if(0===e.length)return;t.push(...e),addInterpolatings(o,e)}}